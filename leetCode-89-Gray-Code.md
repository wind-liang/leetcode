#  题目描述（中等难度）

![](https://windliang.oss-cn-beijing.aliyuncs.com/89.jpg)

生成 n 位格雷码，所谓格雷码，就是连续的两个数字，只有一个 bit 位不同。

# 解法一 动态规划

按照动态规划或者说递归的思路去想，也就是解决了小问题，怎么解决大问题。

我们假设我们有了 n = 2 的解，然后考虑怎么得到 n = 3 的解。

```java
n = 2 的解
00 - 0
10 - 2
11 - 3
01 - 1
```

如果再增加一位，无非是在最高位增加 0 或者 1，考虑先增加 0。由于加的是 0，其实数值并没有变化。

```java
n = 3 的解，最高位是 0
000 - 0
010 - 2
011 - 3
001 - 1    
```

再考虑增加 1，在 n = 2 的解基础上在最高位把 1 丢过去？

```java
n = 3 的解
000 - 0
010 - 2
011 - 3
001 - 1  
------------- 下面的是新增的
100 - 4
110 - 6
111 - 7
101 - 5  
```

似乎没这么简单哈哈，第 4 行 001 和新增的第 5 行 100，有 3 个 bit 位不同了，当然不可以了。怎么解决呢？

很简单，第 5 行新增的数据最高位由之前的第 4 行的 0 变成了 1，所以其它位就不要变化了，直接把第 4 行的其它位拉过来，也就是 101。

接下来，为了使得第 6 行和第 5 行只有一位不同，由于第 5 行拉的第 4 行的低位，而第 4 行和第 3 行只有一位不同。所以第 6 行可以把第 3 行的低位拿过来。其他行同理，如下图。

![](https://windliang.oss-cn-beijing.aliyuncs.com/89_2.jpg)

蓝色部分由于最高位加的是 0 ，所以它的数值和 n = 2 的所有解的情况一样。而橙色部分由于最高位加了 1，所以值的话，就是在其对应的值上加 4，也就是 $$2^2$$，即$$2^{3-1}$$，也就是 1 << ( n - 1) 。所以我们的算法可以用迭代求出来了。

所以如果知道了 n = 2 的解的话，如果是 { 0, 1, 3, 2}，那么 n = 3 的解就是 { 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4 }，即 { 0 1 3 2 6 7 5 4 }。之前的解直接照搬过来，然后倒序把每个数加上 1 << ( n - 1)  添加到结果中即可。

```java
public List<Integer> grayCode(int n) {
    List<Integer> gray = new ArrayList<Integer>();
    gray.add(0); //初始化 n = 0 的解
    for (int i = 0; i < n; i++) {
        int add = 1 << i; //要加的数
        //倒序遍历，并且加上一个值添加到结果中
        for (int j = gray.size() - 1; j >= 0; j--) {
            gray.add(gray.get(j) + add);
        }
    }
    return gray;
}
```

时间复杂度：$$O(2^n)$$，因为有这么多的结果。

空间复杂度：O（1）。

# 解法二 直接推导

解法一我觉得，在不了解格雷码的情况下，还是可以想到的，下边的话，应该是之前了解过格雷码才写出来的。看下[维基百科](<https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81>)提供的一个生成格雷码的思路。

> 以二进制为 0 值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。

以 n = 3 为例。

0 0 0 第零项初始化为 0。

0 0 **1** 第一项改变上一项最右边的位元

0 **1** 1 第二项改变上一项右起第一个为 1 的位元的左边位

0 1 **0** 第三项同第一项，改变上一项最右边的位元

**1** 1 0 第四项同第二项，改变最上一项右起第一个为 1 的位元的左边位

1 1 **1** 第五项同第一项，改变上一项最右边的位元

1 **0** 1 第六项同第二项，改变最上一项右起第一个为 1 的位元的左边位

1 0 **0** 第七项同第一项，改变上一项最右边的位元

思路有了，代码自然也就出来了。

```java
public List<Integer> grayCode2(int n) {
    List<Integer> gray = new ArrayList<Integer>();
    gray.add(0); //初始化第零项
    for (int i = 1; i < 1 << n; i++) {
        //得到上一个的值
        int previous = gray.get(i - 1);
        //同第一项的情况
        if (i % 2 == 1) {
            previous ^= 1; //和 0000001 做异或，使得最右边一位取反
            gray.add(previous);
        //同第二项的情况
        } else {
            int temp = previous;
            //寻找右边起第第一个为 1 的位元
            for (int j = 0; j < n; j++) {
                if ((temp & 1) == 1) {
                    //和 00001000000 类似这样的数做异或，使得相应位取反
                    previous = previous ^ (1 << (j + 1));
                    gray.add(previous);
                    break;
                }
                temp = temp >> 1;
            }
        }
    }
    return gray;
}
```

时间复杂度：由于每添加两个数需要找第一个为 1 的位元，需要 O（n），所以$$O(n2^n)$$。

空间复杂度：O（1）。

# 解法三 公式

二进制转成格雷码有一个公式。

![](https://windliang.oss-cn-beijing.aliyuncs.com/89_3.jpg)

所以我们遍历 0 到 $$2^n-1$$，然后利用公式转换即可。即最高位保留，其它位是当前位和它的高一位进行异或操作。

```java
public List<Integer> grayCode(int n) {
    List<Integer> gray = new ArrayList<Integer>();
    for(int binary = 0;binary < 1 << n; binary++){
        gray.add(binary ^ binary >> 1);
    }
    return gray;
}
```

时间复杂度：$$O(2^n)$$，因为有这么多的结果。

空间复杂度：O（1）。

# 总

解法一通过利用大问题化小问题的思路，解决了问题。解法二和解法三需要对格雷码有一定的了解才可以。此外，通过格雷码还可以去解[汉诺塔](<https://zhuanlan.zhihu.com/p/36124395>)和[九连环](<https://viegg.com/gray/>)的问题，大家有兴趣可以搜一下。